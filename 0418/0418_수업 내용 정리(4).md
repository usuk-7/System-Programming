## 📖 11장 프로그래밍 환경

### 📌 강의 개요
이 강의에서는 프로그래밍 환경에 대한 내용을 다루며, 주요 학습 내용은 다음과 같습니다:
* 프로그램 작성과 컴파일
* 자동 빌드 도구
* gdb 디버거
* 이클립스 통합개발환경
* vi 에디터

---

### ☑️ 11.1 프로그램 작성과 컴파일

#### `gedit` 문서편집기

* **GNU의 대표적인 GUI 텍스트 편집기**이며 GNOME 환경의 기본 편집기이다.
* 텍스트, 프로그램 코드, 마크업 언어 편집에 적합하며 깔끔하고 단순한 GUI를 제공한다.
* **`gedit` 실행 방법**:
    * 메인 메뉴에서 `[프로그램] -> [보조 프로그램] -> [지에디트]` 선택
    * 터미널에서 `$ gedit [파일이름] &` 입력
    * 파일 관리자에서 텍스트 파일 클릭 시 자동 실행
* **`gedit` 메뉴**: 파일, 편집, 보기, 검색, 도구, 문서 등의 메뉴를 제공한다.

#### 단일 모듈 프로그램

* **프로그램 작성**: `gedit`를 이용한다.
* **C 구문 강조 기능**: `gedit`의 `[보기]` 메뉴에서 C 구문 강조 기능을 설정할 수 있다.
    * `#include` 같은 전처리 지시자는 황색으로 표시된다.
    * 주석은 파란색으로 표시된다.
    * 자료형 이름은 초록색으로 표시된다.
    * `if`나 `while` 같은 문장 키워드는 브라운 색으로 표시된다.

#### `gcc` 컴파일러

* **`gcc`(GNU cc) 컴파일러**: C 프로그램을 컴파일하며, 옵션을 사용하지 않으면 실행파일 `a.out`를 생성한다.
* **간단한 컴파일 및 실행**:
    ```bash
    $ gcc longest.c # longest.c를 컴파일하여 a.out 생성
    $ a.out         # a.out 실행
    ```
* **`-c` 옵션**: 목적 파일(`*.o`)을 생성한다.
    ```bash
    $ gcc -c longest.c # longest.c를 컴파일하여 longest.o 생성
    ```
* **`-o` 옵션**: 실행 파일 이름을 지정하여 생성한다.
    ```bash
    $ gcc -o longest longest.o # longest.o를 링크하여 longest 실행 파일 생성
    # 혹은
    $ gcc -o longest longest.c # longest.c를 컴파일하여 longest 실행 파일 생성
    $ longest                  # longest 실행
    ```

#### 다중 모듈 프로그램

* **단일 모듈 프로그램의 문제점**: 코드 재사용이 어렵고, 여러 사람이 참여하는 프로그래밍이 어렵다. (예: `copy` 함수 재사용의 어려움)
* **다중 모듈 프로그램**: 여러 개의 `.c` 파일들로 이루어진 프로그램으로, 복잡하고 대단위 프로그램인 경우에 적합하다.
* **예**: `main` 프로그램과 `copy` 함수를 분리하여 `main.c`, `copy.c`, `copy.h` 파일로 작성한다.
* **컴파일**:
    ```bash
    $ gcc -c main.c  # main.o 생성
    $ gcc -c copy.c  # copy.o 생성
    $ gcc -o main main.o copy.o # 목적 파일들을 링크하여 main 실행 파일 생성
    # 혹은
    $ gcc -o main main.c copy.c # 소스 파일들을 한 번에 컴파일하여 main 실행 파일 생성
    ```

---

### ☑️ 11.2 자동 빌드 도구

#### `make` 시스템의 필요성

* **다중 모듈 프로그램 변경 시**: 변경된 파일만 컴파일하고, 파일들의 의존 관계에 따라 필요한 파일만 다시 컴파일하여 실행 파일을 만들면 효율적이다. (예: `copy.c` 수정 시 `copy.o` 생성 후 실행 파일 재생성)
* **대규모 프로그램 관리**: 헤더, 소스 파일, 목적 파일, 실행 파일의 모든 관계를 체계적으로 관리하기 위해 `make` 시스템이 필요하다.

#### 메이크파일

* **메이크파일**: 실행 파일을 만들기 위해 필요한 파일들, 그들 사이의 의존 관계, 만드는 방법을 기술하는 파일이다.
* **`make` 시스템**: 메이크파일을 이용하여 파일의 상호 의존 관계를 파악하여 실행 파일을 쉽게 다시 만든다.
* **사용법**: `$ make [-f 메이크파일]`
    * `make` 시스템은 `makefile` 혹은 `Makefile`을 이용하여 보통 실행 파일을 빌드한다.
    * 옵션을 사용하여 별도의 메이크파일을 지정할 수 있다.

#### 메이크파일의 구성

* **구성 형식**:
    ```
    목표(target): 의존리스트(dependencies)
    명령리스트(commands)
    ```
* **예시: `Makefile`**:
    ```makefile
    main: main.o copy.o
    	gcc -o main main.o copy.o

    main.o: main.c copy.h
    	gcc -c main.c

    copy.o: copy.c
    	gcc -c copy.c
    ```
* **의존 관계 그래프**: `main`은 `main.o`와 `copy.o`에, `main.o`는 `main.c`와 `copy.h`에, `copy.o`는 `copy.c`에 의존한다.
* **`make` 실행**:
    * `$ make` 또는 `$ make main` 시 `main.o`, `copy.o`를 컴파일하고 `main` 실행 파일을 생성한다.
    * `copy.c` 파일이 변경된 후 `$ make`를 실행하면 `copy.c`만 다시 컴파일하여 `copy.o`를 만들고, `main` 실행 파일을 다시 생성한다.

---

### ☑️ 11.5 `vi` 에디터

#### `vi` 에디터

* 기본 텍스트 에디터로 강력한 기능을 가지고 있으나 배우는 데 상당한 시간과 노력이 필요하다.
* **실행**: `$ vi 파일*`

#### 명령 모드/입력 모드

* `vi` 에디터는 **명령 모드**와 **입력 모드**가 구분되어 있으며, 시작하면 명령 모드이다.
* **모드 전환**:
    * 명령 모드 -> 입력 모드: `i`, `o`, `O`, `a`, `A`
    * 입력 모드 -> 명령 모드: `ESC`
    * 명령 모드 -> 마지막 줄 모드: `:`, `/`, `?`
    * 마지막 줄 모드 -> 명령 모드: `Enter`
* **종료 명령 (마지막 줄 모드)**:
    * `:wq`: 작업 내용을 저장하고 종료한다. (`ZZ`와 동일)
    * `:q`: 아무런 작업을 하지 않은 경우 종료한다.
    * `:q!`: 작업 내용을 저장하지 않고 종료한다.

#### `vi` 내부 명령어

* **커서 이동**: `h` (왼쪽), `j` 또는 `↓` (아래), `k` 또는 `↑` (위), `l` 또는 `→` (오른쪽), `BACKSPACE` (왼쪽), `SPACE` (오른쪽)
* **화면 이동**: `^F` (한 화면 아래), `^B` (한 화면 위), `^D` (반 화면 아래), `^U` (반 화면 위)
* **특정 줄로 이동**: `nG` (n번째 줄), `1G` (첫 줄), `G` (마지막 줄), `:n` (n번째 줄) 등
* **탐색 (search)**: `/탐색패턴` (순방향 탐색), `?탐색패턴` (역방향 탐색)
* **입력모드 전환**:
    * `i`: 커서 위치 앞에 삽입
    * `a`: 커서 위치 뒤에 삽입
    * `I`: 현재 줄의 앞에 삽입
    * `A`: 현재 줄의 뒤에 삽입
    * `o`: 현재 줄의 아래에 전개
    * `O`: 현재 줄의 위에 전개
* **수정 명령**:
    * `r`: 단지 한 글자만 변경
    * `R`: 입력하는 대로 겹쳐 쓰기
    * `S`: 현재 글자 삭제 후 삽입 상태
    * `C`: 커서로부터 줄 끝까지 변경
    * `CC`: 현재 줄 전체 변경
    * `CW`: 현재 단어 삭제 후 변경
* **삭제 명령**:
    * `x`: 커서가 있는 문자 지우기
    * `X`: 커서의 왼쪽 문자 지우기
    * `D`: 커서부터 줄 끝까지 지우기
    * `dw`: 현재 단어 삭제
    * `dd`: 현재 줄 삭제
    * `:n,md`: n~m번째 줄 삭제
* **대체 명령**:
    * `:s/패턴/스트링`: 현재 줄에서 해당되는 첫 번째 단어만 대체
    * `:n,m s/패턴/스트링`: 지정된 줄 범위에서 대체
    * `s/패턴/스트링/g`: 해당되는 모든 단어 대체
* **수행 취소/재수행**:
    * `u`: 방금 전 수행 내용 취소(Undo)
    * `U`: 현재 줄 수행 내용을 취소
    * `.`: 방금 전 수행 내용을 반복(Redo)
* **복사/붙이기**:
    * `nY`: 현재 줄에서부터 n개의 줄을 복사
    * `:n,m y`: n번째 줄에서 m번째 줄까지를 버퍼에 복사
    * `p`: 버퍼 내용을 커서의 뒤(혹은 아래)에 삽입
    * `P`: 버퍼 내용을 커서의 앞(혹은 위)에 삽입
* **파일에 저장**:
    * `:w`: 현재 파일에 저장한다.
    * `:w 파일이름`: 지정된 파일에 저장한다.
* **파일에 저장하고 끝내기**:
    * `:wq`: 현재 파일에 저장하고 종료한다.
    * `ZZ`: 현재 파일에 저장하고 종료한다.
* **저장하지 않고 끝내기**:
    * `:q`: 아무런 작업을 하지 않은 경우 종료.
    * `:q!`: 작업 내용을 저장하지 않고 종료.
* **기타**:
    * **다른 파일 편집**: `:e 파일이름` (현재 파일 대신 주어진 파일 열기), `:e#` (이전 파일 다시 열기)
    * **줄 번호 붙이기**: `:set number` 또는 `:se nu` (줄 번호 붙이기), `:set nonumber` 또는 `:se non` (줄 번호 없애기)
    * **쉘 명령어 수행**: 편집기 내에서 쉘 명령어 수행 (`:!ls`, `:!cat`)

---

### ☑️ 핵심 개념

* **`gedit`**: GNU가 제공하는 대표적인 텍스트 편집기이다.
* **`gcc` 컴파일러**: C 프로그램을 컴파일하며, 옵션을 사용하지 않으면 실행파일 `a.out`를 생성한다.
* **`make` 시스템**: 메이크파일(makefile 혹은 Makefile)을 이용하여 보통 실행 파일을 빌드한다.
* **`gdb` 디버거**: 실행파일을 이용하여 디버깅 모드로 실행한다.
* **`vi` 에디터**: 명령 모드와 입력 모드가 구분되어 있으며 시작하면 명령 모드이다.
