# 📖 0523 수업 내용 정리

## 📌 강의 개요

  - **프로세스 생성**의 핵심 원리와 `fork()` 시스템 호출의 상세한 동작 과정 학습
  - `fork()` 호출 후 생성되는 **부모 프로세스와 자식 프로세스의 관계** 및 메모리 구조 이해
  - `fork()`의 반환값을 이용해 부모와 자식을 구분하고, 각각 **독립적인 작업을 수행**시키는 프로그래밍 기법
  - `wait()` 및 `waitpid()` 시스템 호출을 사용하여 **자식 프로세스의 실행 종료를 대기**하고, 종료 상태(코드)를 확인하는 방법
  - 다수의 자식 프로세스를 생성하고, 특정 자식 프로세스의 종료를 선택적으로 기다리는 방법

-----

## 🔍 핵심 개념

### ☑️ 프로세스 생성: `fork()` 시스템 호출

  - **프로세스란?**: 실행 중인 프로그램을 의미하며, 자신만의 메모리 공간(코드, 데이터, 스택, 힙)과 실행 상태를 가집니다.
  - **프로세스 생성**: 유닉스 계열 시스템에서 새로운 프로세스는 기존 프로세스(부모 프로세스)가 `fork()`라는 특별한 시스템 호출을 통해 자기 자신을 복제함으로써 생성됩니다. 이렇게 새로 생성된 프로세스를 자식 프로세스라고 합니다.

#### `fork()` 시스템 호출의 상세 동작

1.  **자기 복제 (Self-Replication)**:

      * `fork()`가 호출되면, 운영체제 커널은 현재 실행 중인 부모 프로세스의 거의 모든 것을 그대로 복사하여 새로운 자식 프로세스를 만듭니다.
      * 여기에는 부모 프로세스의 **코드 영역(Code Segment)**, **데이터 영역(Data Segment)**, **힙 영역(Heap)**, **스택 영역(Stack)** 이 포함됩니다.
      * 또한, 열린 파일 디스크립터, 환경 변수, 현재 작업 디렉토리 등 대부분의 프로세스 속성도 상속받습니다.

2.  **메모리 복제와 COW (Copy-On-Write)**:

      * 초기에는 자식 프로세스가 부모 프로세스의 메모리 공간을 공유하는 것처럼 보일 수 있지만, 현대 운영체제는 **COW(Copy-On-Write)** 기법을 사용합니다.
      * COW는 `fork()` 직후에는 부모와 자식이 물리적 메모리를 공유하다가, 어느 한쪽이라도 쓰기 작업을 시도하면 그때 해당 메모리 페이지를 복사하여 별도의 공간을 할당하는 방식입니다. 이는 불필요한 메모리 복사를 줄여 `fork()`의 효율성을 높입니다.

3.  **반환 값의 의미**:

      * `fork()` 함수는 **한 번 호출되지만, 두 개의 프로세스에서 각각 반환**합니다. 이는 `fork()`의 가장 독특한 특징입니다.
      * **자식 프로세스**: `fork()`는 자식 프로세스에게 **0**을 반환합니다. 자식 프로세스는 이 값을 통해 자신이 새로 생성된 자식임을 인지할 수 있습니다.
      * **부모 프로세스**: `fork()`는 부모 프로세스에게 방금 생성한 \*\*자식 프로세스의 ID(PID)\*\*를 반환합니다. PID는 양의 정수입니다. 부모는 이 PID를 이용해 특정 자식 프로세스를 관리할 수 있습니다.
      * **실패**: 만약 시스템 자원 부족 등의 이유로 자식 프로세스 생성이 실패하면, 부모 프로세스에게 **-1**이 반환됩니다.

4.  **독립적인 실행**:

      * `fork()` 호출 이후, 부모 프로세스와 자식 프로세스는 **각각 독립적인 실행 흐름**을 갖게 됩니다.
      * 두 프로세스는 `fork()` 호출 다음 명령어부터 각자의 길을 갑니다. (단, 프로그램 카운터(PC) 값은 동일한 지점에서 시작)
      * 어떤 프로세스가 먼저 CPU를 할당받아 실행될지는 스케줄러에 의해 결정되므로 예측하기 어렵습니다.

<!-- end list -->

```c
#include <sys/types.h> // pid_t 타입을 위해 필요
#include <unistd.h>    // fork, getpid 함수를 위해 필요

pid_t fork(void);
// 반환값:
// - 자식 프로세스에게: 0
// - 부모 프로세스에게: 생성된 자식 프로세스의 ID
// - 생성 실패 시: -1
```

#### 🖥️ `fork()` 실행 전후의 메모리 구조 변화

`fork()`가 호출되면, 부모 프로세스(예: PID 15065)의 메모리 내용(코드, 데이터, 힙, 스택)이 새로운 자식 프로세스(예: PID 15066)에게 복제됩니다. 두 프로세스는 `fork()` 호출 직후 동일한 프로그램 카운터(PC) 값을 갖지만, 이후 독립적으로 실행됩니다. `pid` 변수에는 `fork()`의 반환값이 저장되는데, 부모에게는 자식의 PID(15066)가, 자식에게는 0이 저장됩니다.

#### ⌨️ 예제 코드: `fork1.c` (기본적인 fork 사용)

이 예제는 `fork()` 호출 후, 부모 프로세스와 자식 프로세스에서 `getpid()` (자신의 PID를 반환)와 `fork()`의 반환값(`pid` 변수)이 어떻게 출력되는지를 보여줍니다.

```c
#include <stdio.h>
#include <unistd.h>

int main()
{
    pid_t pid; // fork의 반환값을 저장할 변수 (pid_t 타입 사용 권장)

    printf("[%d] 프로세스 시작 \n", getpid());

    pid = fork(); // 여기서 프로세스가 두 개로 나뉨

    // fork() 이후의 코드는 부모와 자식 모두 실행
    printf("[%d] 프로세스 : 리턴값 %d \n", getpid(), pid);

    return 0;
}

/*
실행 결과 예시 (PID는 실행 시마다 변경됨):
[15065] 프로세스 시작
[15065] 프로세스 : 리턴값 15066  // 부모 프로세스: getpid()는 자신의 PID, pid는 자식의 PID
[15066] 프로세스 : 리턴값 0      // 자식 프로세스: getpid()는 자신의 PID, pid는 0
(출력 순서는 스케줄링에 따라 바뀔 수 있음)
*/
```

-----

### ☑️ 부모-자식 프로세스 구분 및 작업 분리

`fork()`의 반환값은 부모 프로세스와 자식 프로세스에서 다르게 나타나므로, 이 값을 조건문(`if-else if-else`)으로 확인하여 각 프로세스가 서로 다른 코드를 실행하도록 만들 수 있습니다.

```c
#include <stdio.h>
#include <unistd.h>
#include <stdlib.h> // exit 함수를 위해 필요

int main()
{
    pid_t pid;
    pid = fork();

    if (pid == 0) {
        // 여기는 자식 프로세스만 실행하는 코드
        printf("[Child]: 안녕하세요! 제 PID는 %d이고, fork()로부터 0을 받았습니다.\n", getpid());
        // 자식 프로세스는 보통 exec 계열 함수로 새로운 프로그램을 실행하거나,
        // 주어진 작업을 수행한 후 exit()로 종료합니다.
        exit(0); // 자식 프로세스 정상 종료
    }
    else if (pid > 0) {
        // 여기는 부모 프로세스만 실행하는 코드
        printf("[Parent]: 안녕하세요! 제 PID는 %d이고, 방금 만든 자식의 PID는 %d입니다.\n", getpid(), pid);
        // 부모 프로세스는 자식 프로세스가 종료되기를 기다리거나(wait),
        // 다른 작업을 계속 수행할 수 있습니다.
    }
    else {
        // pid < 0 인 경우: fork() 호출 실패
        perror("fork()가 실패했습니다");
        exit(1); // 오류 종료
    }
    return 0; // 부모 프로세스 정상 종료 (자식이 먼저 exit() 할 수 있음)
}
```

#### ⌨️ 예제 코드: `fork3.c` (두 개의 자식 프로세스 생성 및 관리)

부모 프로세스는 `fork()`를 순차적으로 두 번 호출하여 두 개의 자식 프로세스를 생성할 수 있습니다. 각 자식 프로세스는 독립적으로 자신에게 할당된 메시지를 출력하고 `exit(0)`를 통해 정상 종료합니다. 부모 프로세스는 모든 자식 프로세스를 생성한 후 자신의 메시지를 출력합니다. (실제 안정적인 프로그램에서는 부모가 `wait()` 시스템 호출로 자식들의 종료를 기다려야 합니다.)

```c
#include <stdlib.h>
#include <stdio.h>
#include <unistd.h>

int main()
{
    pid_t pid1, pid2;

    pid1 = fork(); // 첫 번째 자식 생성 시도
    if (pid1 == 0) {
        // 첫 번째 자식 프로세스의 코드
        printf("[Child 1]: 첫 번째 자식입니다! PID = %d\n", getpid());
        exit(0); // 첫 번째 자식 종료
    } else if (pid1 < 0) {
        perror("첫 번째 fork 실패");
        exit(1);
    }

    // 여기는 부모 프로세스만 도달 (첫 번째 fork 성공 시)
    pid2 = fork(); // 두 번째 자식 생성 시도
    if (pid2 == 0) {
        // 두 번째 자식 프로세스의 코드
        printf("[Child 2]: 두 번째 자식입니다! PID = %d\n", getpid());
        exit(0); // 두 번째 자식 종료
    } else if (pid2 < 0) {
        perror("두 번째 fork 실패");
        // 이미 생성된 첫 번째 자식이 고아 프로세스가 되지 않도록 처리 필요 (wait 등)
        exit(1);
    }

    // 여기는 부모 프로세스만 도달 (두 번째 fork도 성공 시)
    printf("[Parent]: 부모 프로세스입니다! PID = %d. 자식1 PID = %d, 자식2 PID = %d\n", getpid(), pid1, pid2);

    // 부모는 자식들이 모두 종료될 때까지 기다리는 것이 좋음 (wait, waitpid 사용)
    // wait(NULL); // 첫 번째 종료하는 자식을 기다림
    // wait(NULL); // 두 번째 종료하는 자식을 기다림
    // 위와 같이 처리하면 고아/좀비 프로세스 방지에 도움됨

    return 0;
}
/*
실행 결과 예시 (출력 순서 및 PID는 매번 다를 수 있음):
[Parent]: 부모 프로세스입니다! PID = 15740. 자식1 PID = 15741, 자식2 PID = 15742
[Child 1]: 첫 번째 자식입니다! PID = 15741
[Child 2]: 두 번째 자식입니다! PID = 15742
*/
```

-----

### ☑️ 자식 프로세스 기다리기: `wait()` 및 `waitpid()`

부모 프로세스가 자식 프로세스의 작업 완료를 기다리거나, 자식이 어떻게 종료되었는지(정상 종료, 오류 종료, 시그널에 의한 종료 등) 확인해야 할 때 사용하는 시스템 호출입니다. 이를 통해 좀비 프로세스(이미 종료되었지만 부모가 상태를 수거하지 않아 시스템에 남아있는 프로세스)가 발생하는 것을 방지할 수 있습니다.

#### `wait()` 시스템 호출

  - `wait()`는 호출한 부모 프로세스의 자식 프로세스 중 **임의의 하나가 종료될 때까지** 부모 프로세스의 실행을 일시 중단(block)시킵니다.
  - 종료된 자식 프로세스의 ID를 반환하며, 인자로 전달된 포인터 `status`에는 자식의 종료 상태 정보가 저장됩니다.
  - 더 이상 기다릴 자식 프로세스가 없거나 오류 발생 시 -1을 반환합니다.

<!-- end list -->

```c
#include <sys/types.h>
#include <sys/wait.h>

pid_t wait(int *status);
```

  - **종료 코드 추출**: `status`에 저장된 값은 여러 정보를 포함하므로, 자식 프로세스가 `exit()`로 전달한 실제 종료 코드(exit status)를 얻기 위해서는 일반적으로 `WEXITSTATUS(status)` 매크로를 사용하거나, 간단히 `status >> 8` (오른쪽으로 8비트 시프트) 연산을 사용합니다. (단, `WIFEXITED(status)` 매크로로 정상 종료 여부를 먼저 확인하는 것이 안전합니다.)

#### `waitpid()` 시스템 호출

  - `waitpid()`는 `wait()`보다 더 세밀한 제어를 제공합니다.
      - `pid` 인자를 통해 특정 PID를 가진 자식 프로세스만 기다리거나, 특정 프로세스 그룹의 자식을 기다릴 수 있습니다.
          - `pid > 0`: 해당 PID를 가진 자식을 기다립니다.
          - `pid == 0`: 호출한 프로세스와 동일한 프로세스 그룹에 속한 자식을 기다립니다.
          - `pid == -1`: `wait()`와 동일하게 임의의 자식을 기다립니다.
          - `pid < -1`: `-pid` 값에 해당하는 프로세스 그룹 ID를 가진 자식을 기다립니다.
      - `options` 인자를 통해 논블로킹(non-blocking) 대기(`WNOHANG`), 특정 상태의 자식만 기다리기 등의 추가 기능을 사용할 수 있습니다.

<!-- end list -->

```c
pid_t waitpid(pid_t pid, int *status, int options);
```

#### ⌨️ 예제 코드: `forkwait.c` (기본적인 `wait` 사용)

이 예제에서 부모 프로세스는 `fork()`로 자식을 생성한 후, `wait()`를 호출하여 자식이 종료될 때까지 기다립니다. 자식은 메시지를 출력하고 `exit(1)`로 종료하며, 부모는 자식의 PID와 종료 코드를 출력합니다.

```c
#include <sys/types.h>
#include <sys/wait.h>
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>

int main()
{
    pid_t pid_fork_return, child_pid_from_wait;
    int status_from_wait;

    printf("[%d] 부모 프로세스 시작 \n", getpid());

    pid_fork_return = fork();

    if (pid_fork_return == 0) {
        // 자식 프로세스
        printf("[%d] 자식 프로세스 시작 \n", getpid());
        sleep(1); // 자식 프로세스가 약간의 작업을 하는 것을 시뮬레이션
        printf("[%d] 자식 프로세스 종료 예정 (종료 코드: 1)\n", getpid());
        exit(1); // 종료 코드 1로 자식 프로세스 종료
    }
    else if (pid_fork_return > 0) {
        // 부모 프로세스
        printf("[%d] 부모 프로세스: 자식 %d의 종료를 기다립니다...\n", getpid(), pid_fork_return);
        child_pid_from_wait = wait(&status_from_wait); // 자식 프로세스가 끝날 때까지 대기

        if (child_pid_from_wait == -1) {
            perror("wait 실패");
        } else {
            printf("[%d] 부모 프로세스: 자식 프로세스 %d가 종료되었습니다.\n", getpid(), child_pid_from_wait);
            if (WIFEXITED(status_from_wait)) { // 자식이 정상적으로 exit() 했는지 확인
                printf("\t자식의 종료 코드는 %d 입니다.\n", WEXITSTATUS(status_from_wait));
            } else {
                printf("\t자식이 비정상적으로 종료되었습니다.\n");
            }
        }
    }
    else {
        // fork 실패
        perror("fork 실패");
        exit(1);
    }
    return 0;
}
/*
실행 결과 예시:
[15943] 부모 프로세스 시작
[15943] 부모 프로세스: 자식 15944의 종료를 기다립니다...
[15944] 자식 프로세스 시작
[15944] 자식 프로세스 종료 예정 (종료 코드: 1)
[15943] 부모 프로세스: 자식 프로세스 15944가 종료되었습니다.
        자식의 종료 코드는 1 입니다.
*/
```

#### ⌨️ 예제 코드: `waitpid.c` (특정 자식 프로세스 기다리기)

두 개의 자식 프로세스(Child 1, Child 2)를 생성하고, 각각 다른 시간 동안 `sleep`합니다. 부모 프로세스는 `waitpid(pid1, ...)`를 사용하여 명시적으로 Child 1이 종료되기를 먼저 기다린 후, Child 1의 종료 상태를 출력합니다. Child 2는 Child 1이 종료된 후에도 계속 실행될 수 있습니다. (안정적인 프로그램에서는 모든 자식의 종료를 처리해야 합니다.)

```c
#include <sys/types.h>
#include <sys/wait.h>
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>

int main()
{
    pid_t pid1, pid2;
    pid_t child_pid_from_wait;
    int status_from_wait;

    printf("[%d] 부모 프로세스 시작 \n", getpid());

    pid1 = fork(); // 첫 번째 자식 생성
    if (pid1 == 0) {
        printf("[%d] 자식 프로세스[1] 시작 (1초 후 종료)\n", getpid());
        sleep(1);
        printf("[%d] 자식 프로세스[1] 종료 (종료 코드: 1)\n", getpid());
        exit(1);
    } else if (pid1 < 0) { perror("첫 번째 fork 실패"); exit(1); }

    pid2 = fork(); // 두 번째 자식 생성
    if (pid2 == 0) {
        printf("[%d] 자식 프로세스[2] 시작 (2초 후 종료)\n", getpid());
        sleep(2);
        printf("[%d] 자식 프로세스[2] 종료 (종료 코드: 2)\n", getpid());
        exit(2);
    } else if (pid2 < 0) { perror("두 번째 fork 실패"); exit(1); }


    // 부모 프로세스: 첫 번째 자식(pid1)의 종료를 기다림
    printf("[%d] 부모: 자식 프로세스[1] (%d)의 종료를 기다립니다...\n", getpid(), pid1);
    child_pid_from_wait = waitpid(pid1, &status_from_wait, 0);

    if (child_pid_from_wait == pid1) {
        printf("[%d] 부모: 자식 프로세스[1] (%d)가 종료되었습니다.\n", getpid(), child_pid_from_wait);
        if (WIFEXITED(status_from_wait)) {
            printf("\t자식[1]의 종료 코드는 %d 입니다.\n", WEXITSTATUS(status_from_wait));
        }
    } else {
        perror("waitpid(pid1) 실패 또는 다른 자식이 종료됨");
    }

    // 실제로는 두 번째 자식(pid2)의 종료도 기다려야 함
    // child_pid_from_wait = waitpid(pid2, &status_from_wait, 0);
    // ... (pid2에 대한 상태 처리) ...

    printf("[%d] 부모 프로세스 종료.\n", getpid());
    return 0;
}
/*
실행 결과 예시:
[16840] 부모 프로세스 시작
[16840] 부모: 자식 프로세스[1] (16841)의 종료를 기다립니다...
[16841] 자식 프로세스[1] 시작 (1초 후 종료)
[16842] 자식 프로세스[2] 시작 (2초 후 종료)
[16841] 자식 프로세스[1] 종료 (종료 코드: 1)
[16840] 부모: 자식 프로세스[1] (16841)가 종료되었습니다.
        자식[1]의 종료 코드는 1 입니다.
[16842] 자식 프로세스[2] 종료 (종료 코드: 2) // 이 시점에 부모는 이미 다음 코드로 진행했을 수 있음
[16840] 부모 프로세스 종료.
*/
```
