# 📖 0411 학습 내용 정리

## 🏷️ 강의 주제: 쉘과 명령어 사용

## 📌 강의 개요
이 장에서는 쉘의 기본 개념, 종류, 주요 기능과 리눅스/유닉스 시스템에서의 효과적인 명령어 사용법(입출력 재지정, 파이프, 여러 명령어 실행, 대치 기능 등)을 학습합니다.

---

## 🔍 핵심 개념

### ☑️ 5.1 쉘 소개

#### 1. 쉘(Shell)이란 무엇인가?
- **쉘의 역할**: 사용자와 운영체제 사이의 인터페이스, 명령어 처리기.
  ```bash
  [사용자] --명령어--> [쉘] --명령어 실행--> [운영체제/커널]
  ```
#### 2. 쉘의 종류
| 쉘의 종류 | 쉘 실행 파일 |
| :-------- | :------------- |
| 본 쉘     | `/bin/sh`      |
| 콘 쉘     | `/bin/ksh`     |
| C 쉘      | `/bin/csh`     |
| Bash      | `/bin/bash`    |
| tcsh      | `/bin/tcsh`    |
- **주요 쉘 요약**:
- **본 쉘**: 유닉스 기본 쉘.
- **Bash**: 리눅스/맥 OS X 기본 쉘, 본 쉘 확장.
- **C 쉘**: C 언어 특징 포함, `tcsh`로 개선.

#### 3. 로그인 쉘 (login shell)
- 로그인 시 자동 실행되는 쉘, 시스템 관리자가 지정.
- 예: `/etc/passwd` 파일에서 `chang:x:109:101:Ubuntu:/home/chang:/bin/bash` 같이 마지막 필드에 지정.

#### 4. 로그인 쉘 변경
- 현재 쉘 임시 변경: `csh` (C 쉘로), `exit` (복귀).
- 기본 로그인 쉘 변경: `chsh` 명령어 사용 후 재로그인.

---

### ☑️ 5.2 쉘의 기능

#### 1. 쉘의 주요 기능
- **명령어 처리**: 사용자 명령 해석 및 프로그램 실행.
- **시작 파일**: 로그인 시 사용자 환경 설정 파일 자동 실행.
- **스크립트**: 쉘 프로그래밍 기능으로 작업 자동화.

#### 2. 쉘의 실행 절차
- 시작 파일 읽고 실행 → 프롬프트 출력 및 사용자 명령 대기 → 사용자 명령 실행 (종료는 Control-D).

#### 3. 쉘의 환경 변수
- 설정: `$ 환경변수명=값` (예: `$ TERM=xterm`)
- 자식 프로세스 전달: `export 환경변수명`
- 보기: `$ env`

#### 4. 쉘의 시작 파일 (start-up file)
- 쉘 시작 시 자동 실행되어 사용자 환경 설정.
- **시스템 시작 파일** (모든 사용자 공통) vs **사용자 시작 파일** (개인별 설정, 홈 디렉터리에 위치).
- **주요 Bash 시작 파일**:
- `~/.bash_profile`: 로그인 시 실행.
- `~/.bashrc`: 로그인 및 새 쉘 시작 시 실행.
- **시작 파일 바로 적용**: `$ . ~/.bash_profile` 또는 `$ source ~/.bash_profile`

---

### ☑️ 5.3 전면 처리와 후면 처리

- **전면 처리**: 명령어 실행 완료까지 대기. (`$ 명령어`)
- **후면 처리**: 명령어 백그라운드 실행, 다른 작업 가능. (`$ 명령어 &`)
- 예: `$ (sleep 100; echo done) &`
- **후면 작업 확인**: `$ jobs`
- **후면 작업을 전면으로**: `$ fg %작업번호`

---

### ☑️ 5.4 입출력 재지정

- **출력 재지정 (`>`)**: 명령어 출력을 파일에 저장 (덮어씀).
- 예: `$ ls -l > file.txt`
- **출력 추가 (`>>`)**: 명령어 출력을 파일 끝에 추가.
- 예: `$ date >> file.txt`
- **입력 재지정 (`<`)**: 파일 내용을 명령어 입력으로 사용.
- 예: `$ wc < file.txt`
- **Here Document (`<< 단어 ... 단어`)**: 특정 단어 사이의 내용을 명령어 입력으로.
- 예: `$ wc << ENDOFTEXT`
- **오류 재지정 (`2>`)**: 표준 오류를 파일에 저장.
- 예: `$ ls /nonexistent 2> error.log`
- **파이프 (`|`)**: 한 명령어의 출력을 다른 명령어의 입력으로 전달.
- 예: `$ ls | sort -r`
- **입출력 재지정 요약**
  
| 명령어 사용법               | 의미                                       |
| :-------------------------- | :----------------------------------------- |
| `명령어 > 파일`             | 표준 출력을 파일에 저장 (덮어씀).            |
| `명령어 >> 파일`            | 표준 출력을 파일에 추가.                     |
| `명령어 < 파일`             | 파일 내용을 표준 입력으로 사용.              |
| `명령어 << 단어`            | '단어'까지의 내용을 표준 입력으로 사용.      |
| `명령어 2> 파일`            | 표준 오류를 파일에 저장.                     |
| `명령어1 \| 명령어2`         | 명령어1 출력을 명령어2 입력으로 전달.        |

---

### ☑️ 5.5 여러 개 명령어 실행

- **명령어 열 (`;`)**: 여러 명령어를 순차적으로 실행.
- 예: `$ date; pwd; ls`
- **명령어 그룹 (`()`)**: 여러 명령어를 그룹으로 묶어 (서브쉘에서) 실행, 그룹 전체의 입출력 재지정 가능.
- 예: `$ (date; pwd; ls) > output.txt`
- **조건부 실행 (`&&`, `||`)**:
- `명령어1 && 명령어2`: 명령어1 성공 시 명령어2 실행.
  - 예: `$ gcc myprog.c && ./a.out`
- `명령어1 || 명령어2`: 명령어1 실패 시 명령어2 실행.
  - 예: `$ gcc myprog.c || echo 컴파일 실패`

---

### ☑️ 5.6 파일 이름 대치와 명령어 대치

#### 1. 파일 이름 대치 (Globbing)
- 대표문자(Wildcards)로 여러 파일 지정:
- `*`: 0개 이상 모든 문자 (예: `*.txt`)
- `?`: 임의의 한 문자 (예: `file?.log`)
- `[...]`: 대괄호 안의 문자 중 하나 (예: `[abc]*.c`)

#### 2. 명령어 대치 (Command Substitution)
- 명령어 실행 결과를 다른 명령어의 일부로 사용:
- `` `명령어` `` 또는 `$(명령어)`
- 예: `$ echo "현재 시간: $(date)"`
- 예: `$ echo "파일 개수: $(ls | wc -w)"`

#### 3. 따옴표 사용 (Quoting)
- 쉘의 특수 문자 기능 제한:
- **작은따옴표 (`'...'`)**: 내부 모든 특수문자 기능 억제 (문자 그대로).
  - 예: `$ echo '내 이름은 $USER, 오늘은 $(date)'`
- **큰따옴표 (`"..."`)**: `$`, `` ` ``(또는 `$()`), `\`를 제외한 특수문자 기능 억제 (변수/명령어 대치 허용).
  - 예: `$ echo "내 이름은 $USER, 오늘은 $(date)"`

---

### ☑️ 핵심 개념 요약 (마무리)
- **쉘**: 사용자와 OS 간의 명령어 처리기.
- **입출력 재지정**: 명령어의 입력, 출력, 오류 대상을 변경 (`>`, `>>`, `<`, `2>`).
- **파이프**: 한 명령어의 출력을 다른 명령어의 입력으로 연결 (`|`).
- **명령어 실행**: 순차적 (`;`), 그룹 (`()`), 조건부 (`&&`, `||`).
- **대치**: 파일 이름 (`*`, `?`, `[]`), 명령어 (`` ` `` 또는 `$()`).
- **따옴표**: 특수 문자 해석 제어 (`'`, `"`).

---
