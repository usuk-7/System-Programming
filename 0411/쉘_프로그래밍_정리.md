# 🐧 쉘 스크립트 프로그래밍 핵심 요약

## 🎯 강의 개요
이 문서는 리눅스 쉘 스크립트 프로그래밍의 핵심 개념들을 요약하여, 반복적인 작업을 자동화하고 시스템 관리 작업을 효율적으로 처리할 수 있도록 돕는 것을 목표로 합니다. 다양한 예제와 함께 쉘 스크립트의 기본부터 고급 활용법까지 다룹니다.

---

## 🔍 핵심 개념

### ☑️ 1. 스크립트 기본 구조 및 실행

* **셔뱅 (Shebang)**: 스크립트 첫 줄에는 스크립트를 실행할 인터프리터를 지정합니다.
    ```bash
    #!/bin/bash
    ```
* **주석**: `#` 기호 뒤의 내용은 주석으로 처리되어 실행되지 않습니다. 스크립트에 대한 설명을 추가할 때 유용합니다.
* **명령어 실행**: 스크립트 내 명령어들은 한 줄에 하나씩 작성하거나, 세미콜론 (`;`)을 사용하여 한 줄에 여러 명령어를 작성할 수 있습니다.
* **실행 권한**: 스크립트 파일을 실행하려면 `chmod` 명령어로 실행 권한을 부여해야 합니다.
    ```bash
    chmod u+x 스크립트파일이름
    ```
* **스크립트 실행**: 스크립트 파일이 현재 디렉토리에 있다면 `./스크립트파일이름` 과 같이 경로를 명시하여 실행합니다. `PATH` 환경 변수에 스크립트 디렉토리가 등록되어 있다면 파일 이름만으로 실행 가능합니다.

---

### ☑️ 2. 메시지 출력 및 변수 활용

* **`echo` 명령어**: 터미널에 문자열이나 변수 값을 출력합니다.
    * `-n` 옵션: 출력 후 줄바꿈을 하지 않습니다.
    * **따옴표**:
        * 작은따옴표 (`'`): 내부의 모든 문자를 그대로 인식합니다.
        * 큰따옴표 (`"`): 변수 치환 (`$변수명`)이나 특정 이스케이프 시퀀스를 해석합니다.
* **환경 변수**: 시스템에 미리 정의된 변수들 (예: `$HOME`, `$USER`, `$PATH`, `$UID`)을 스크립트 내에서 참조하여 사용할 수 있습니다. `set` 명령으로 현재 환경 변수 목록을 볼 수 있습니다.
* **사용자 정의 변수**: 스크립트 내에서 임의의 이름으로 변수를 만들어 값을 저장하고 사용할 수 있습니다.
    * **선언 및 할당**: `변수명=값` (등호 앞뒤 공백 없음).
        ```bash
        myVar="Hello World"
        count=10
        ```
    * **참조**: `$변수명` 또는 `${변수명}` (변수명 뒤에 다른 문자가 바로 이어질 때 명확한 구분을 위해 중괄호 사용).
        ```bash
        echo $myVar
        echo "User is ${USER}."
        ```
    * 값 할당 시, 값에 공백이 포함되어 있다면 큰따옴표로 묶어주는 것이 안전합니다.
* **명령 치환**: 명령어의 실행 결과를 변수에 담거나 다른 명령어의 인자로 사용할 수 있습니다.
    * **백틱 (역따옴표)**:
        ```bash
        current_date=`date`
        ```
    * **달러-괄호**: (가독성이 좋고 중첩 사용이 용이하여 권장됨)
        ```bash
        file_list=$(ls)
        ```

---

### ☑️ 3. 입출력 리디렉션

| 명령어 사용법          | 의미                                      | 예시                                    |
| :--------------------- | :---------------------------------------- | :-------------------------------------- |
| `명령어 > 파일`        | 표준 출력을 파일에 저장 (덮어씀).         | `ls -l > file_list.txt`                 |
| `명령어 >> 파일`       | 표준 출력을 파일에 추가.                  | `date >> log.txt`                       |
| `명령어 < 파일`        | 파일 내용을 표준 입력으로 사용.           | `wc -l < file.txt`                      |
| `명령어 << MARKER`     | `MARKER`까지의 내용을 표준 입력으로 사용. | `cat << EOF > newfile.txt`              |
| `명령어 2> 파일`       | 표준 오류를 파일에 저장.                  | `grep "pattern" non_existent_file 2> error.log` |
| `명령어1 \| 명령어2`    | 명령어1 출력을 명령어2 입력으로 전달.     | `ps aux \| grep "bash"`                 |

* **Here Document (`<< MARKER`)**:
    ```bash
    cat << EOF
    이것은 히어 다큐먼트의 예시입니다.
    여러 줄을 입력할 수 있습니다.
    EOF
    ```

---

### ☑️ 4. 산술 연산

* **`expr` 명령어**: 구형 방식의 정수 연산 및 문자열 처리를 지원합니다. 연산자는 쉘에 의해 특별한 의미로 해석될 수 있으므로 백슬래시 (`\`)로 이스케이프해야 할 때가 많습니다.
    ```bash
    val1=10
    val2=5
    result_expr=$(expr $val1 \* $val2) # 곱셈
    echo "expr 결과: $result_expr"
    ```
* **Bash 산술 확장 (`$[...]` 또는 `$((...))`)**: Bash 쉘에서 정수 연산을 보다 편리하게 수행할 수 있는 방법입니다. `expr`보다 직관적이며 특수 문자 이스케이프가 덜 필요합니다. (이 방식은 정수 연산만 지원합니다.)
    ```bash
    result_bash=$((val1 * val2 / 2))
    echo "Bash 산술 확장 결과: $result_bash"
    ```
* **`bc` (Basic Calculator)**: 부동 소수점 연산이 필요할 때 사용하는 외부 프로그램입니다.
    * `scale` 변수를 설정하여 소수점 이하 자릿수를 지정할 수 있습니다.
        ```bash
        float_result=$(echo "scale=4; 10 / 3" | bc)
        echo "bc 결과 (소수점): $float_result"
        ```

---

### ☑️ 5. 종료 상태 (Exit Status)

* 모든 명령어는 실행 후 **종료 상태 값**을 반환합니다. 이 값은 특수 변수 `$?` 에 저장됩니다.
* **성공**: 종료 상태 값 `0`
* **실패**: `0` 이 아닌 값 (오류의 종류에 따라 다른 값을 가질 수 있음)
* 스크립트의 최종 종료 상태는 마지막으로 실행된 명령어의 종료 상태가 됩니다.
* **`exit` 명령어**: 스크립트를 특정 종료 상태 값으로 강제 종료시킬 수 있습니다. (예: `exit 0` 또는 `exit 1`). 값은 0~255 사이여야 하며, 이 범위를 넘어서면 모듈로 연산된 값이 사용됩니다.
    ```bash
    if [ ! -f "myfile.txt" ]; then
      echo "오류: myfile.txt 파일이 존재하지 않습니다."
      exit 1
    fi
    echo "파일 처리 완료."
    exit 0
    ```

---

### ☑️ 6. 조건 분기 (Structured Commands)

#### 1️⃣ `if` 문
특정 조건의 참/거짓에 따라 다른 명령을 실행합니다. 조건은 주로 명령어의 종료 상태를 기반으로 판단합니다.

* **기본 구조**:
    ```bash
    if 명령어_또는_test_조건
    then
        명령어들1
    fi
    ```
* **`if-else` 구조**:
    ```bash
    if 명령어_또는_test_조건
    then
        명령어들1
    else
        명령어들2
    fi
    ```
* **`if-elif-else` 구조 (다중 조건)**:
    ```bash
    if 명령어_또는_test_조건1
    then
        명령어들1
    elif 명령어_또는_test_조건2
    then
        명령어들2
    else
        명령어들3
    fi
    ```

#### 2️⃣ `test` 명령어 (또는 `[ 조건 ]`)
파일 유형, 문자열 비교, 숫자 비교 등 다양한 조건을 테스트하여 참이면 종료 상태 0을, 거짓이면 1을 반환합니다. `if` 문과 함께 매우 빈번하게 사용됩니다.

* ‼️ **주의**: 대괄호 `[` 와 `]` 사이에는 반드시 공백이 있어야 합니다. (예: `if [ "$var" -gt 10 ]`)
* **주요 `test` 조건**:

    | 구분     | 연산자 (의미)                                                                                                                              | 예시                                      |
    | :------- | :--------------------------------------------------------------------------------------------------------------------------------------- | :---------------------------------------- |
    | 숫자 비교 | `-eq` (같음), `-ne` (같지 않음), `-lt` (작음), `-le` (작거나 같음), `-gt` (큼), `-ge` (크거나 같음)                                               | `[ $count -eq 0 ]`                        |
    | 문자열 비교 | `=` 또는 `==` (같음, `=`가 더 이식성 높음), `!=` (같지 않음), `-z 문자열` (문자열이 비어있으면 참), `-n 문자열` (문자열이 비어있지 않으면 참) | `[ "$name" = "root" ]`                    |
    |          | 문자열 비교 시 `>`, `<` 연산자는 이스케이프 (`\>`, `\<`) 필요                                                                                    | `[ "$str1" \> "$str2" ]`                  |
    | 파일 조건 | `-e` (존재), `-f` (일반 파일), `-d` (디렉토리), `-r` (읽기 가능), `-w` (쓰기 가능), `-x` (실행 가능), `-s` (크기가 0보다 큼)                     | `[ -f "/etc/passwd" ]`                    |
    |          | `파일1 -nt 파일2` (파일1이 최신), `파일1 -ot 파일2` (파일1이 오래됨)                                                                          | `[ "file1.txt" -nt "file2.txt" ]`         |

* ‼️ `test` 명령어는 부동 소수점 숫자를 직접 비교할 수 없습니다.

---

### ☑️ 7. 반복문 (Looping Constructs)

#### 1️⃣ `for` 루프
지정된 목록의 각 항목에 대해 반복적으로 명령을 실행합니다.

* **기본 구조**:
    ```bash
    for 변수 in 목록
    do
        명령어들 # $변수를 사용하여 현재 항목에 접근
    done
    ```
* `목록`은 공백으로 구분된 값들, 변수, 명령어의 결과 (명령 치환 사용) 등이 될 수 있습니다.
    ```bash
    # 예시 1: 숫자 목록
    for i in 1 2 3 4 5
    do
      echo "숫자: $i"
    done

    # 예시 2: 파일 목록
    for file in *.txt
    do
      echo "텍스트 파일: $file"
    done

    # 예시 3: 명령어 결과
    for user_dir in $(ls /home)
    do
      echo "사용자 홈 디렉토리: /home/$user_dir"
    done
    ```
* ‼️ 목록의 항목에 공백이나 특수 문자가 포함된 경우, 각 항목을 큰따옴표로 묶어주어야 합니다.

#### 2️⃣ `while` 루프
특정 조건이 참인 동안 계속해서 명령을 반복 실행합니다. 조건은 루프 시작 시 평가됩니다.

* **기본 구조**:
    ```bash
    while 명령어_또는_test_조건
    do
        명령어들
        # 루프 조건을 변경하는 로직이 필요 (무한 루프 방지)
    done
    ```
    ```bash
    # 예시: 카운터
    counter=1
    while [ $counter -le 5 ]
    do
      echo "현재 카운터: $counter"
      counter=$((counter + 1))
    done
    ```
* 조건으로 사용되는 명령어는 주로 `test` (또는 `[ ]`) 입니다.

#### 3️⃣ `until` 루프
특정 조건이 참이 될 때까지 계속해서 명령을 반복 실행합니다. `while`과 반대로 조건이 거짓인 동안 루프가 실행됩니다.

* **기본 구조**:
    ```bash
    until 명령어_또는_test_조건
    do
        명령어들
        # 루프 조건을 변경하는 로직이 필요
    done
    ```
    ```bash
    # 예시: 카운터 (until 사용)
    counter=1
    until [ $counter -gt 5 ]
    do
      echo "현재 카운터 (until): $counter"
      counter=$((counter + 1))
    done
    ```
* ‼️ `while`과 `until` 모두 여러 테스트 명령을 조건으로 사용할 수 있으며, 이때 마지막 테스트 명령의 종료 상태가 루프의 지속 여부를 결정합니다.
