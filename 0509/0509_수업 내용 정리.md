# 📖 0509 수업 내용 정리

## 📌 강의 개요

  - \*\*시스템 호출(System Call)\*\*의 개념과 **커널 모드**로의 전환 과정 이해
  - 유닉스(Unix) 시스템의 **파일 개념**과 **파일 디스크립터**의 역할 학습
  - 파일을 다루기 위한 필수 시스템 호출 학습:
      - `open()`, `creat()`: 파일 열기 및 생성
      - `close()`: 파일 닫기
      - `read()`, `write()`: 데이터 읽기 및 쓰기
      - `dup()`, `dup2()`: 파일 디스크립터 복제
  - **파일 위치 포인터**의 개념과 `lseek()`를 이용한 임의 접근(Random Access) 방법
  - 시스템 호출을 활용한 기본 유틸리티(`fsize`, `copy`) 및 데이터베이스 프로그램 작성 실습

-----

## 🔍 핵심 개념

### ☑️ 시스템 호출 (System Call)

  - **커널(Kernel)**: 운영체제의 핵심으로, 하드웨어 자원을 관리하고 응용 프로그램에 파일 관리, 프로세스 관리, 메모리 관리 등 필수 서비스를 제공합니다.
  - **시스템 호출**: 응용 프로그램이 이러한 커널의 서비스를 이용하기 위한 공식적인 요청 창구(인터페이스)입니다. `open`, `read`와 같은 C 라이브러리 함수는 내부적으로 시스템 호출을 통해 커널에 작업을 요청합니다.

#### 🖥️ 시스템 호출 과정

1.  **사용자 모드**: 응용 프로그램이 C 라이브러리 함수(예: `open()`)를 호출합니다.
2.  **모드 전환**: 라이브러리 함수 내부에서 `trap` 명령어가 실행됩니다. 이 명령어는 CPU를 **사용자 모드**에서 **커널 모드**로 전환시키고, 커널 내의 정해진 코드로 제어를 넘깁니다.
3.  **커널 모드**: 커널은 시스템 호출 테이블을 참조하여 요청된 서비스(예: 커널의 `open` 기능)를 실행합니다.
4.  **복귀**: 작업 완료 후, 커널은 다시 사용자 모드로 전환하고 실행 결과를 응용 프로그램에 반환합니다.

-----

### ☑️ 파일 입출력 시스템 호출

#### 1️⃣ `open()` / `creat()` - 파일 열기 및 생성

  - 파일을 다루려면 가장 먼저 `open()`을 통해 파일을 열고, 운영체제로부터 **파일 디스크립터(File Descriptor)** 를 받아야 합니다. 파일 디스크립터는 열린 파일을 식별하는 음이 아닌 정수입니다.
  - `creat()`는 파일을 생성하고 쓰기 전용으로 여는 함수로, `open()`에 특정 플래그 조합을 사용한 것과 동일합니다.

```c
#include <fcntl.h> // O_XXX 플래그 정의

int open(const char *path, int oflag, [ mode_t mode ]);
int creat(const char *path, mode_t mode); // open(path, O_WRONLY|O_CREAT|O_TRUNC, mode)와 동일
```

  - **주요 `oflag` 옵션 (Bitwise OR `|`로 조합)**
    | `oflag` 옵션 | 설명 |
    | :--- | :--- |
    | `O_RDONLY` | 읽기 전용으로 엽니다. |
    | `O_WRONLY` | 쓰기 전용으로 엽니다. |
    | `O_RDWR` | 읽기/쓰기 겸용으로 엽니다. |
    | `O_APPEND` | 항상 파일의 끝에 데이터를 추가합니다. |
    | `O_CREAT` | 파일이 없으면 새로 생성합니다. `mode` 인자로 권한을 지정해야 합니다. (예: `0644`) |
    | `O_TRUNC` | 파일이 이미 존재하면 내용을 모두 지웁니다. |
    | `O_EXCL` | `O_CREAT`와 함께 사용하며, 파일이 이미 존재하면 오류를 발생시킵니다. |

#### 2️⃣ `close()` - 파일 닫기

  - 사용이 끝난 파일 디스크립터를 반환하여 시스템 리소스를 해제합니다.

```c
#include <unistd.h>
int close(int fd);
```

#### 3️⃣ `read()` / `write()` - 데이터 읽고 쓰기

  - `read()`: 파일에서 데이터를 읽어와 버퍼에 저장합니다. 파일의 끝(EOF)에 도달하면 0을 반환합니다.
  - `write()`: 버퍼의 데이터를 파일에 씁니다.

```c
#include <unistd.h>

ssize_t read(int fd, void *buf, size_t nbytes);  // 성공: 읽은 바이트 수, EOF: 0, 실패: -1
ssize_t write(int fd, const void *buf, size_t nbytes); // 성공: 쓴 바이트 수, 실패: -1
```

#### ⌨️ 예제 코드: `copy.c` (파일 복사 프로그램)

```c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <fcntl.h>

/* 파일 복사 프로그램 */
int main(int argc, char *argv[])
{
    int fd1, fd2, n;
    char buf[BUFSIZ];

    if (argc != 3) {
        fprintf(stderr,"사용법: %s file1 file2\n", argv[0]);
        exit(1);
    }

    if ((fd1 = open(argv[1], O_RDONLY)) == -1) {
        perror(argv[1]);
        exit(2);
    }
    if ((fd2 = open(argv[2], O_WRONLY | O_CREAT | O_TRUNC, 0644)) == -1) {
        perror(argv[2]);
        exit(3);
    }

    while ((n = read(fd1, buf, BUFSIZ)) > 0)
        write(fd2, buf, n); // 읽은 내용을 그대로 쓴다.

    exit(0);
}
```

#### 4️⃣ `dup()` / `dup2()` - 파일 디스크립터 복제

  - 기존 파일 디스크립터를 복제하여 새로운 디스크립터를 생성합니다. 두 디스크립터는 같은 파일을 가리키고 **파일 위치 포인터를 공유**하므로, 한쪽에서 `read/write`하면 다른 쪽에도 영향을 줍니다.

```c
#include <unistd.h>

int dup(int oldfd);
int dup2(int oldfd, int newfd);
```

#### ⌨️ 예제 코드: `dup.c`

```c
#include <unistd.h>
#include <fcntl.h>
#include <stdlib.h>
#include <stdio.h>

int main()
{
    int fd1, fd2;
    if((fd1 = creat("myfile", 0600)) == -1)
        perror("myfile");

    write(fd1, "Hello! Linux", 12);
    fd2 = dup(fd1); // fd1을 복제하여 fd2 생성
    write(fd2, "Bye! Linux", 10); // fd2에 쓰면 fd1 파일에 이어서 쓰여짐

    exit(0);
}
// 실행 결과: $ cat myfile
// Hello! LinuxBye! Linux
```

-----

### ☑️ 파일 위치 포인터와 `lseek()`

  - **파일 위치 포인터(File Position Pointer)**: 모든 열린 파일은 내부에 다음에 읽거나 쓸 위치를 가리키는 포인터를 가집니다. `read()`나 `write()`를 하면 이 포인터는 작업한 바이트 수만큼 자동으로 이동합니다.
  - `lseek()`는 이 포인터를 원하는 위치로 강제 이동시켜 파일의 특정 부분에 직접 접근(Random Access)하게 해주는 시스템 호출입니다.

```c
#include <unistd.h>
off_t lseek(int fd, off_t offset, int whence);
```

  - **`whence` 옵션**:
      - `SEEK_SET`: 파일의 시작 지점을 기준으로 `offset` 만큼 이동 (`lseek(fd, 100L, SEEK_SET);`)
      - `SEEK_CUR`: 현재 위치를 기준으로 `offset` 만큼 이동 (`lseek(fd, -sizeof(rec), SEEK_CUR);`)
      - `SEEK_END`: 파일의 끝 지점을 기준으로 `offset` 만큼 이동 (`lseek(fd, 0L, SEEK_END);`)

#### ⌨️ 예제 코드: `dbupdate.c` (레코드 수정)

`lseek`는 학생 정보 DB와 같은 레코드 기반 파일을 수정할 때 매우 유용합니다.

```c
// ... (파일을 O_RDWR 모드로 연 후)
// 1. 수정할 레코드 위치로 이동
lseek(fd, (long)(id - START_ID) * sizeof(record), SEEK_SET);

// 2. 레코드 읽기
read(fd, (char *)&record, sizeof(record));

// ... (메모리에서 점수 등 정보 수정)

// 3. 다시 원래 위치로 돌아가기 (read로 인해 포인터가 이동했으므로)
lseek(fd, (long)-sizeof(record), SEEK_CUR);

// 4. 수정된 레코드 덮어쓰기
write(fd, (char *)&record, sizeof(record));
```

-----

# 📖 시스템 프로그래밍: 파일 시스템

## 📌 강의 개요

  - 리눅스 **파일 시스템의 물리적 구조** (부트 블록, 슈퍼 블록, i-리스트, 데이터 블록) 이해
  - 파일의 모든 정보를 담고 있는 \*\*i-노드(i-Node)\*\*의 상세 구조와 **블록 포인터**의 역할 학습
  - 파일 I/O 시 커널 내부에서 사용되는 자료구조(**파일 디스크립터 배열, 파일 테이블, 동적 i-노드 테이블**)의 상호작용 방식
  - `stat()` 계열 시스템 호출을 이용한 **파일의 상태 정보 및 권한** 확인 방법
  - **디렉토리**의 구현 원리와 관련 라이브러리 함수(`opendir`, `readdir`) 사용법
  - 파일에 여러 이름을 부여하는 **하드 링크**와 **심볼릭 링크**의 차이점 및 관련 시스템 호출

-----

## 🔍 핵심 개념

### ☑️ 파일 시스템의 논리적 구조

리눅스 파일 시스템은 디스크를 효율적으로 사용하기 위해 다음과 같은 논리적 영역으로 나뉩니다.

| 영역 | 상세 설명 |
| :--- | :--- |
| **부트 블록** | 파일 시스템의 가장 맨 앞에 위치하며, 컴퓨터 전원이 켜질 때 운영체제를 메모리로 불러오는 부트스트랩 코드를 담고 있습니다. |
| **슈퍼 블록** | 파일 시스템의 '명세서'와 같습니다. 전체 블록의 수, 사용 가능한 i-노드의 개수, 블록의 크기 등 파일 시스템 전체를 관리하기 위한 총체적인 정보를 저장합니다. |
| **i-리스트** | 파일 시스템 내 모든 파일과 디렉터리에 대한 i-노드들이 모여 있는 영역입니다. |
| **데이터 블록** | 실제 파일의 내용(데이터)이 저장되는 가장 큰 영역입니다. |

-----

### ☑️ i-노드 (i-Node)

  - **i-노드란?**: 'index-node'의 약자로, 파일의 실제 내용을 제외한 **모든 메타데이터**를 담고 있는 자료구조입니다. 각 파일이나 디렉터리는 고유한 i-노드 하나와 연결됩니다.

  - **저장 정보**:

      - 파일 종류 (일반 파일, 디렉터리, 심볼릭 링크 등)
      - 파일 접근 권한 (읽기, 쓰기, 실행)
      - 파일 소유자 및 그룹의 ID
      - 파일 크기, 링크 수, 각종 시간 정보(생성, 수정, 접근)
      - **데이터 블록 포인터**: 실제 데이터가 저장된 데이터 블록의 주소

  - **블록 포인터**: 큰 파일도 효율적으로 관리하기 위해 여러 단계의 포인터를 사용합니다.

      - **직접 포인터**: 데이터 블록을 직접 가리킵니다. (보통 10\~12개)
      - **단일 간접 포인터**: 데이터 블록 포인터 목록을 담고 있는 블록을 가리킵니다.
      - **이중/삼중 간접 포인터**: 더 큰 파일을 위해 간접 포인터를 여러 단계 거쳐 가리킵니다.

-----

### ☑️ 파일 입출력을 위한 커널 자료구조

사용자가 `open()` 함수를 호출하면, 커널은 다음과 같은 3가지 자료구조를 유기적으로 사용하여 파일을 관리합니다.

1.  **파일 디스크립터 배열 (per-process)**: 각 프로세스는 자신만의 파일 디스크립터 배열을 가집니다. 배열의 인덱스가 `fd` 값이며, 각 항목은 시스템 전역의 '열린 파일 테이블'의 엔트리를 가리킵니다.
2.  **열린 파일 테이블 (system-wide)**: 시스템에 단 하나만 존재하며, 현재 열린 모든 파일을 관리합니다. 각 항목은 파일의 열기 모드(R/W), 파일 위치 포인터, 그리고 '동적 i-노드 테이블'을 가리키는 포인터를 포함합니다.
3.  **동적 i-노드 테이블 (system-wide)**: 디스크에 있는 i-노드의 복사본을 메모리에 유지하여 빠르게 접근할 수 있도록 합니다. 파일의 권한, 크기 등 고유 정보가 들어있습니다.

-----

### ☑️ 파일 상태 정보와 권한

#### `stat()` 시스템 호출

  - 파일의 i-노드에 저장된 모든 상세 정보를 `struct stat` 구조체에 담아 반환합니다.
  - `lstat()`은 대상이 심볼릭 링크일 경우, 링크 자체의 정보를 반환합니다.

```c
#include <sys/stat.h>

struct stat {
    mode_t    st_mode;    // 파일 타입과 사용권한
    ino_t     st_ino;     // i-노드 번호
    nlink_t   st_nlink;   // 하드 링크 수
    uid_t     st_uid;     // 소유자의 사용자 ID
    gid_t     st_gid;     // 소유자의 그룹 ID
    off_t     st_size;    // 파일 크기(bytes)
    time_t    st_mtime;   // 최종 수정 시간
    blkcnt_t  st_blocks;  // 파일의 블록 수
    ...
};
```

#### 파일 타입 검사

  - `st_mode` 필드의 값을 이용해 파일 타입을 검사하는 매크로 함수들이 제공됩니다.
    | 매크로 함수 | 설명 |
    | :--- | :--- |
    | `S_ISREG()` | 일반 파일인가? |
    | `S_ISDIR()` | 디렉터리인가? |
    | `S_ISCHR()` | 문자 장치 파일인가? |
    | `S_ISBLK()` | 블록 장치 파일인가? |
    | `S_ISLNK()` | 심볼릭 링크인가? |

#### `chmod()`, `chown()`, `utime()`

  - `chmod()`: 파일의 접근 권한(r, w, x)을 변경합니다.
  - `chown()`: 파일의 소유자(user)와 그룹(group)을 변경합니다.
  - `utime()`: 파일의 최종 접근 시간과 수정 시간을 변경합니다.

-----

### ☑️ 디렉토리와 링크

#### 디렉토리 구현

  - 리눅스에서 디렉토리도 일종의 '특수 파일'입니다. 이 파일의 내용은 **디렉토리 엔트리(`struct dirent`)** 들의 목록입니다.
  - 각 엔트리는 '파일 이름'과 그 파일에 해당하는 'i-노드 번호'의 쌍으로 이루어져 있습니다.

#### `opendir()`, `readdir()`

  - `opendir()`로 디렉토리를 열고, `readdir()`를 반복 호출하여 디렉토리 내의 모든 파일과 서브 디렉토리 목록을 순차적으로 읽을 수 있습니다.

#### 하드 링크 vs 심볼릭 링크

| 구분 | **하드 링크 (Hard Link)** | **심볼릭 링크 (Symbolic Link)** |
| :--- | :--- | :--- |
| **구현** | 여러 디렉토리 엔트리가 **하나의 i-노드를 공유** | 원본 파일의 **경로를 담고 있는** 별도의 파일 |
| **i-노드** | 원본과 동일한 i-노드 사용 (링크 수 증가) | 자신만의 고유 i-노드를 가짐 |
| **제약사항** | 같은 파일 시스템 내에서만 가능, 디렉토리 링크 불가 | 파일 시스템 간 연결 가능, 디렉토리 링크 가능 |
| **원본 삭제 시**| 원본 파일에 영향 없음 (링크 수가 1 이상이면) | 링크가 끊어짐 (Dangling Link) |
| **시스템 호출**| `link()`, `unlink()` | `symlink()`, `readlink()` |

---
